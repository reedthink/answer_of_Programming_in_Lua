# 第一章

1.2 -l参数不要加lua后缀，dofile要dofile('test.lua')

练习1.5 ： 表达式 type(nil)==nil 的值是什么？你可以直接在 Lua 中运行来得到答案，但是你能够解释原因吗？
> true，因为nil的类型的值和值的类型相同  

1.6 除了使用函数 type 外， 如何检查一个值是否为 Boolean 类型？
> 判断这个值是否与false或true相等
```lua
function judgeBool(x)
    if (x == true or x == false) then
        return true
    end
    return false
end
```
练习1.8 ： 请编写一个可以打印 出脚本自身名称的程序（事先不知道脚本自身的名称）。
```LUA
print(arg[0])
```
# 第二章
八皇后问题，见 eight_queen.lua
全排列调用 isplaceok 的次数是回溯法的二十倍

# 第三章
3.2 （这个问题涉及到机器码的问题，将数字转换成机器码再计算，之后转回真值，很简明。下方描述中，二进制均表示机器码）  
## 注意：溢出在数学概念上就是取模了

math.maxinteger * 2    --> -2  
原因：math.maxinteger的二进制 ：  
0111111111111111111111111111111111111111111111111111111111111111  
往左移位，最右加一个0，是  
1111111111111111111111111111111111111111111111111111111111111110  
对应的十六进制机器位 0xFFFFFFFFFFFFFFFE 对应的真值也就是-2

math.mininteger * 2   --> 0  
对应二进制:  
1000000000000000000000000000000000000000000000000000000000000000  
乘二后的二进制:
0000000000000000000000000000000000000000000000000000000000000000  
显然是0

math.maxinteger * math.maxinteger  
同样采用移位的思路分析，已知maxinteger是奇数，那么就是math.maxinteger的二进制移位n次后再加一个数m，首先确定n是多少，math.maxinteger 是2^63+(-1),n是63， 之后确定m，m=-1
先把math.maxinteger 左移 63位，为：
1000000000000000000000000000000000000000000000000000000000000000  
对应真值 mininteger  （也就是-2^64）  
再加上-math.maxinteger（二进制
1000000000000000000000000000000000000000000000000000000000000001
）,  
1000000000000000000000000000000000000000000000000000000000000000  
+  
1000000000000000000000000000000000000000000000000000000000000001  

结果是：
0000000000000000000000000000000000000000000000000000000000000001  

显然真值为1

math.mininteger * math.mininteger --> 0
可以从补码乘法的角度理解，具体参考补码乘法。  
https://web.archive.org/web/20150213203512/http://pages.cs.wisc.edu/~cs354-1/beyond354/int.mult.html

方便起见，以4位计算机为例：（有符号整数范围-8到7）


              11111000        -8
    	   x  11111000     x  -8
          ----------------    ------
    	      00000000         
    	     00000000
    	    00000000
           11111000
          11111000
         11111000
        11111000
       11111000
      ----------------
       111000001000000
截断后四位，真值是0, 同理，math.mininteger * math.mininteger的结果也是0

值得一提的是，如果观察后8位，同样能得出64的正确真值，而这个数对16取模依然是0（等效于溢出后的运算结果）

